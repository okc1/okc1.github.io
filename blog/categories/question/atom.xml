<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://www.shuati123.com/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://www.shuati123.com/"/>
  <updated>2017-05-22T02:03:16-07:00</updated>
  <id>http://www.shuati123.com/</id>
  <author>
    <name><![CDATA[Kevin Durant]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Trie Wildcard String Matching]]></title>
    <link href="http://www.shuati123.com/blog/2017/05/22/Trie-Wildcard-String-Matching/"/>
    <updated>2017-05-22T00:00:00-07:00</updated>
    <id>http://www.shuati123.com/blog/2017/05/22/Trie-Wildcard-String-Matching</id>
    <content type="html"><![CDATA[# Question

[link](https://discuss.leetcode.com/topic/54332/wildcard-on-trie/2)

> Given a trie data struture, implement add() and search() method, which support wildcard matching.

eg. If trie contains ["cool", "kid", "kindle", "kind"]

These would match: "co*l", "kind", "***"

These won't: "**", "kid*", "coo"

# Solution

First, know how to build a trie, then know how to search in Trie. This could be tricky. Do Read On!

1. Trie (root) start with an empty node. 
2. When do searching, __ALWAYS assumes that current TrieNode is matched__. I.e. do not check value of current TrieNode. Instead, check current TrieNode's children, and find a match.
3. The only case __you return true__, is when matching reaches current TrieNode, and __current TrieNode is an terminating node for a word__. 
4. Be careful and __do not confuse yourself__ for which node you gonna match, and when you return true. 

Read the code below. If you still have a hard time, read #2 and #3 above, again. 


# Code

	public boolean solve(TrieRoot trie, String word) {
		if (word == null || word.length() == 0) {
			return false;
		}
		return matchFromChildren(trie.getRoot(), word, 0);
	}
	
	private boolean matchFromChildren(TrieNode node, String word, int index) {
		// [important note] 
		// regardless of the value of node.letter, match word[index...] from node.children
		
		if (index > word.length()) {
			// impossible to reach here
			return false;
		} else if (index == word.length()) {
			// word is now fully matched, check if isTerminalNode(node)
			return node.isEndOfWord();
		}
		
		char curLetter = word.charAt(index);
		if (curLetter == '*') {
			for (TrieNode child: node.getAllChildren()) {
				if (matchFromChildren(child, word, index + 1)) {
					return true;
				}
			}
			return false;
		} else {
			TrieNode nextNode = node.getChild(curLetter);
			if (nextNode == null) {
				return false;
			} else {
				return matchFromChildren(nextNode, word, index + 1);
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Dutch National Flag Problem]]></title>
    <link href="http://www.shuati123.com/blog/2017/05/13/dutch-national-flag/"/>
    <updated>2017-05-13T00:00:00-07:00</updated>
    <id>http://www.shuati123.com/blog/2017/05/13/dutch-national-flag</id>
    <content type="html"><![CDATA[# Question

[link](https://en.wikipedia.org/wiki/Dutch_national_flag_problem)

> Given an array A[] consisting 0s, 1s and 2s, write a function that sorts A[]. The functions should put all 0s first, then all 1s and all 2s in last.

    Example
    Input = {0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1};
    Output = {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2}

# Solution

3-way sort: http://www.geeksforgeeks.org/3-way-quicksort-dutch-national-flag/

# Code

	public int[] threePointerSort(int[] input) {
		if (input == null || input.length <= 1) {
			return input;
		}

		// left is at the leftmost non-0 position
		// right is at rightmost non-2
		// mid is currently being evaluated (before mid, it's sorted)
		int left = 0, right = input.length - 1;
		int mid = left;
		
		while (mid <= right) {
			if (input[mid] > 1) {
				Common.swap(input, mid, right);
				right--;
			} else if (input[mid] < 1) {
				Common.swap(input, left, mid);
				left++;
				mid++;
			} else {
				mid++;
			}
		}

		return input;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Swizzle Sort]]></title>
    <link href="http://www.shuati123.com/blog/2015/11/21/swizzle-sort/"/>
    <updated>2015-11-21T00:00:00-08:00</updated>
    <id>http://www.shuati123.com/blog/2015/11/21/swizzle-sort</id>
    <content type="html"><![CDATA[# Question

[link](http://www.mitbbs.com/article_t/Recommend/31493121.html)

> 输入一个数组，要求输出满足：a[0]<=a[1]>=a[2]<=a[3]>=…

# Solution

> O(n)，一边扫描即可。发现不符合条件的只要跟前面一个数对调就可以，

# Code

	public int[] solve(int[] input) {
		boolean incr = true;
		int len = input.length;
		int p = 1;
		while (p < len) {
			if (incr ^ (input[p - 1] < input[p])) {
				Common.swap(input, p - 1, p);
			}
			p++;
			incr = !incr;
		}
		return input;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Partition Problem (Divide Array Into Halves)]]></title>
    <link href="http://www.shuati123.com/blog/2015/11/15/partition-problem/"/>
    <updated>2015-11-15T00:00:00-08:00</updated>
    <id>http://www.shuati123.com/blog/2015/11/15/partition-problem</id>
    <content type="html"><![CDATA[# Question

[link](http://www.geeksforgeeks.org/dynamic-programming-set-18-partition-problem/)

> [partition problem](https://en.wikipedia.org/wiki/Partition_problem) is the task of deciding whether a given multiset S of positive integers can be partitioned into two subsets S1 and S2 such that the sum of the numbers in S1 equals the sum of the numbers in S2.  

> Examples

    arr[] = {1, 5, 11, 5}
    Output: true 
    The array can be partitioned as {1, 5, 5} and {11}

    arr[] = {1, 5, 3}
    Output: false 
    The array cannot be partitioned into equal sum sets.

# Solution

__DP__ (only if sum of the elements is not too big).

> [We can create a 2D array](http://www.geeksforgeeks.org/dynamic-programming-set-18-partition-problem/) of size (sum/2)*(n+1). And we can construct the solution in bottom up manner such that every filled entry has following property:

    part[i][j] = 
        true if a subset of {arr[0], arr[1], ..arr[j-1]} has sum equal to i
        false otherwise

Note that we always cares about __whether there exist a valid subset from beginning to index i__. 

Example DP array for input "3,1,1,2,2,1":

<img class="middle" src="/assets/images/partition-problem-dp.jpg">

# Code
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Largest Sub-square With Edges Filled]]></title>
    <link href="http://www.shuati123.com/blog/2015/10/07/largest-subsquare-with-edge-filled/"/>
    <updated>2015-10-07T00:00:00-07:00</updated>
    <id>http://www.shuati123.com/blog/2015/10/07/largest-subsquare-with-edge-filled</id>
    <content type="html"><![CDATA[### Question

[link](www.geeksforgeeks.org/given-matrix-o-x-find-largest-subsquare-surrounded-x/index.html)

> Given a matrix where every element is either ‘O’ or ‘X’, find the largest sub-square surrounded by ‘X’. (meaning that the 4 edges are filled with 'X')

> Example Input:

     {'X', 'O', 'X', 'X', 'X'},
     {'X', 'X', 'X', 'X', 'X'},
     {'X', 'X', 'O', 'X', 'O'},
     {'X', 'X', 'X', 'X', 'X'},
     {'X', 'X', 'X', 'O', 'O'},


> Output: 3. The square submatrix starting at (1, 1) is the largest sub-squre. 

> Example Input:

     {'X', 'O', 'X', 'X', 'X', 'X'},
     {'X', 'O', 'X', 'X', 'O', 'X'},
     {'X', 'X', 'X', 'O', 'O', 'X'},
     {'X', 'X', 'X', 'X', 'X', 'X'},
     {'X', 'X', 'X', 'O', 'X', 'O'},

> Output: 4. The square submatrix starting at (0, 2) is the largest

### Solution

Read a very similar question - __[Question] Maximum Square Sub-matrix With All 1s__

Typical DP question. Now the solution is to build 2 arrays to cache info. One horizontally and one, vertical. 

> create two auxiliary arrays hor[N][N] and ver[N][N]. 

> hor[i][j] is the number of horizontal continuous ‘X’ characters till mat[i][j] in mat[][]. 

> ver[i][j] is the number of vertical continuous ‘X’ characters till mat[i][j] in mat[][]. 

    mat[6][6] =  X  O  X  X  X  X
                 X  O  X  X  O  X
                 X  X  X  O  O  X
                 O  X  X  X  X  X
                 X  X  X  O  X  O
                 O  O  X  O  O  O

    hor[6][6] = 1  0  1  2  3  4
                1  0  1  2  0  1
                1  2  3  0  0  1
                0  1  2  3  4  5
                1  2  3  0  1  0
                0  0  1  0  0  0

    ver[6][6] = 1  0  1  1  1  1
                2  0  2  2  0  2
                3  1  3  0  0  3
                0  2  4  1  1  4
                1  3  5  0  2  0
                0  0  6  0  0  0

After we got these, start from the bottom-right corner row by row up... For every mat[i][j], we compare hor[i][j] with ver[i][j] and pick the smaller one. 

All we need to do next, is to check the other 2 edges. This solution is O(n^3).

### Code 

C++ code provided by [G4G](www.geeksforgeeks.org/given-matrix-o-x-find-largest-subsquare-surrounded-x/index.html):

    int findSubSquare(int mat[][N])
    {
        int max = 1; // Initialize result

        // Initialize the left-top value in hor[][] and ver[][]
        int hor[N][N], ver[N][N];
        hor[0][0] = ver[0][0] = (mat[0][0] == 'X');

        // Fill values in hor[][] and ver[][]
        for (int i=0; i<N; i++)
        {
            for (int j=0; j<N; j++)
            {
                if (mat[i][j] == 'O')
                    ver[i][j] = hor[i][j] = 0;
                else
                {
                    hor[i][j] = (j==0)? 1: hor[i][j-1] + 1;
                    ver[i][j] = (i==0)? 1: ver[i-1][j] + 1;
                }
            }
        }

        // Start from the rightmost-bottommost corner element and find
        // the largest ssubsquare with the help of hor[][] and ver[][]
        for (int i = N-1; i>=1; i--)
        {
            for (int j = N-1; j>=1; j--)
            {
                // Find smaller of values in hor[][] and ver[][]
                // A Square can only be made by taking smaller
                // value
                int small = getMin(hor[i][j], ver[i][j]);

                // At this point, we are sure that there is a right
                // vertical line and bottom horizontal line of length
                // at least 'small'.

                // We found a bigger square if following conditions
                // are met:
                // 1)If side of square is greater than max.
                // 2)There is a left vertical line of length >= 'small'
                // 3)There is a top horizontal line of length >= 'small'
                while (small > max)
                {
                    if (ver[i][j-small+1] >= small &&
                        hor[i-small+1][j] >= small)
                    {
                        max = small;
                    }
                    small--;
                }
            }
        }
        return max;
    }
]]></content>
  </entry>
  
</feed>
