<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Q-facebook | Woodstock Blog]]></title>
  <link href="http://okc1.github.io/blog/categories/q-facebook/atom.xml" rel="self"/>
  <link href="http://okc1.github.io/"/>
  <updated>2016-06-13T01:11:53-07:00</updated>
  <id>http://okc1.github.io/</id>
  <author>
    <name><![CDATA[Kevin Durant]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Facebook] Generate Number With Given Probability]]></title>
    <link href="http://okc1.github.io/blog/2015/02/08/generate-number-with-given-probability/"/>
    <updated>2015-02-08T00:00:00-08:00</updated>
    <id>http://okc1.github.io/blog/2015/02/08/generate-number-with-given-probability</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://blog.sina.com.cn/s/blog_b9285de20101h463.html">link</a></p>

<blockquote><p>给定一个随机函数可以按照0.5的概率返回true。</p>

<p>要求实现一个函数随机返回任意概率的true。</p></blockquote>

<h3>Solution</h3>

<p>Eg. 0.25 true, then should be:</p>

<ol>
<li><p>generate once. If false, return false, else&hellip;</p></li>
<li><p>generate again, directly return.</p></li>
</ol>


<p>So, always return result for the possibility larger than 0.5. This recursion might go on forever.</p>

<p>Read code below.</p>

<h3>Code</h3>

<p>not my code</p>

<pre><code>boolean RNGwithGivenProb(double p, boolean expected)
{
   if(p &lt; 0.5)
       return RNGwithGivenProb(1 - p, !expected);  
   if(RNG() == expected)
       return expected;
   else
       return RNGwithGivenProb((p - 0.5) * 2, expected);
}

boolean RNG()
{
   return T/F with 0.5 probability.
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Scheduling Jobs With Max Cost]]></title>
    <link href="http://okc1.github.io/blog/2015/01/07/scheduling-jobs-with-max-cost/"/>
    <updated>2015-01-07T00:00:00-08:00</updated>
    <id>http://okc1.github.io/blog/2015/01/07/scheduling-jobs-with-max-cost</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.glassdoor.com/Interview/Given-a-set-of-n-jobs-with-start-time-end-time-cost-find-a-subset-so-that-no-2-jobs-overlap-and-the-cost-is-maximum-QTN_440168.htm">link</a></p>

<blockquote><p>Given a set of n jobs with [start time, end time, cost], find a subset so that no 2 jobs overlap and the cost is maximum.</p>

<p>Let&rsquo;s assume the input is already sorted by start_time.</p></blockquote>

<h3>Solution</h3>

<p><a href="http://cs.stackexchange.com/a/14237">Somebody</a> mentioned <strong>Interval Graph</strong>, so check it out if you interested!</p>

<p>I am going to discuss both DP and recursive solution.</p>

<p>This question reminds me of <strong>[Question] 0-1 Knapsack Problem</strong> and <strong>[Question] Coin Change Problem</strong>, cuz the basic idea is to compare 2 conditions:</p>

<ol>
<li>include current element</li>
<li>or, not include current element</li>
</ol>


<p>A very good DP solution is presented in <a href="http://cs.stackexchange.com/a/16842">here</a>. The code below is written by me and it&rsquo;s very intuitive to read.</p>

<p>Leave me a comment if you have questions. And one more thing~ Happy new year!</p>

<h3>Code</h3>

<p>Dp</p>

<pre><code>private int dpSolution(Job[] jobs, int size) {
    int[] dp = new int[size];
    dp[size - 1] = jobs[size - 1].cost;
    // cost of last job equals to just itself
    for (int k = size - 2; k &gt;= 0; k--) {
        int next = findNextJob(jobs, k);
        int includeK = jobs[k].cost;
        if (next &lt; size) {
            includeK += dp[next];
        }
        int excludeK = dp[k + 1];
        dp[k] = Math.max(includeK, excludeK);
    }
    return dp[0];
}

private int findNextJob(Job[] jobs, int k) {
    int finishTime = jobs[k].finish;
    int next = k + 1;
    while (next &lt; jobs.length) {
        if (jobs[next].start &lt; finishTime) {
            next++;
        } else {
            break;
        }
    }
    return next;
}
</code></pre>

<p>Recursion</p>

<pre><code>public int recursiveSolution(Job[] jobs, int size, int k) {
    // max cost from (k)th job and onwards
    if (k == size) {
        return 0;
    }
    // (k)th job must not conflict with any previous job
    int next = findNextJob(jobs, k);
    int includeK = jobs[k].cost + recursiveSolution(jobs, size, next);
    int excludeK = recursiveSolution(jobs, size, k + 1);
    return Math.max(includeK, excludeK);
}

private int findNextJob(Job[] jobs, int k) {
    int finishTime = jobs[k].finish;
    int next = k + 1;
    while (next &lt; jobs.length) {
        if (jobs[next].start &lt; finishTime) {
            next++;
        } else {
            break;
        }
    }
    return next;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Write a Json Prettifier]]></title>
    <link href="http://okc1.github.io/blog/2015/01/06/Json-prettifier/"/>
    <updated>2015-01-06T00:00:00-08:00</updated>
    <id>http://okc1.github.io/blog/2015/01/06/Json-prettifier</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.glassdoor.com/Interview/Write-a-function-to-prettify-Json-objects-QTN_151361.htm">link</a></p>

<p>Input:
    {&ldquo;firstName&rdquo;:&ldquo;John&rdquo;,&ldquo;lastName&rdquo;:&ldquo;Smith&rdquo;,&ldquo;isAlive&rdquo;:true,&ldquo;age&rdquo; :25,&ldquo;height_cm&rdquo;:167.6,&ldquo;address&rdquo;:{&ldquo;streetAddress&rdquo;:&ldquo;212ndStre et&rdquo;,&ldquo;city&rdquo;:&ldquo;NewYork&rdquo;,&ldquo;state&rdquo;:&ldquo;NY&rdquo;,&ldquo;postalCode&rdquo;:&ldquo;10021-3100&rdquo; },&ldquo;phoneNumbers&rdquo;:[{&ldquo;type&rdquo;:&ldquo;home&rdquo;,&ldquo;number&rdquo;:&ldquo;212555-1234&rdquo;},{&ldquo; type&rdquo;:&ldquo;office&rdquo;,&ldquo;number&rdquo;:&ldquo;646555-4567&rdquo;}],&ldquo;children&rdquo;:[],&ldquo;spou se&rdquo;:null}</p>

<p>Output:</p>

<pre><code>{
  "firstName": "John",
  "lastName": "Smith",
  "isAlive": true,
  "age": 25,
  "height_cm": 167.6,
  "address": {
    "streetAddress": "21 2nd Street",
    "city": "New York",
    "state": "NY",
    "postalCode": "10021-3100"
  },
  "phoneNumbers": [
    {
      "type": "home",
      "number": "212 555-1234"
    },
    {
      "type": "office",
      "number": "646 555-4567"
    }
  ],
  "children": [],
  "spouse": null
}
</code></pre>

<h3>Solution</h3>

<p>Since I did not find anything useful online, I spent an hour writing the following code. These are the things to take into consideration:</p>

<ol>
<li><p><strong>Line break</strong> after a comma, a left bracket, or prior to a right bracket. A special pattern is &ldquo;},&rdquo; - we only do line break once after the comma.</p></li>
<li><p><strong>Indentation</strong> is important. It&rsquo;s a little complex cuz we reduce indentation <strong>BEFORE</strong> printing out a right bracket, but increase indentation <strong>AFTER the left bracket</strong>.</p></li>
</ol>


<h3>Code</h3>

<pre><code>public void prettify(String input) throws Exception {

    // observation the rules for Json format:
    // 1. each line end with either a { , or }
    // 2. indentation depends on number of brackets
    int len = input.length();
    int left = 0;
    int right = 0;
    int tab = 0;

    while (left &lt; len) {
        // first, advance right pointer to the next line break point
        while (right &lt; len) {
            if (input.charAt(right) == '}' || input.charAt(right) == ']') {
                // first case, if point to a closing bracket
                tab--;
                // indentation should change right away should we find a
                // closing bracket
                if (right + 1 &lt; len &amp;&amp; input.charAt(right + 1) != ',') {
                    break;
                }
            } else if (input.charAt(right) == ','
                    || input.charAt(right) == '{'
                    || input.charAt(right) == '[') {
                // second case, break at , or {
                break;
            } else if (right + 1 &lt; len
                    &amp;&amp; (input.charAt(right + 1) == '}' || input
                            .charAt(right + 1) == ']')) {
                // third case, break prior to }
                // we need not swap the order of first and third case,
                // because when we found a closing bracket, we need to
                // change indentation right away
                break;
            }
            right++;
        }

        // now print the chars from left pointer to right inclusively
        if (right == len) {
            // end of input
            if (tab != 0) {
                throw new Exception("Json format error!");
            }
            right--;
            // this is for the convenience of printing last line
        }
        printIndentation(tab);
        System.out.println(input.substring(left, right + 1));
        if (input.charAt(right) == '{' || input.charAt(right) == '[') {
            tab++;
        }

        // last, update pointers
        left = ++right;
    }
}

private void printIndentation(int tab) {
    for (int i = 0; i &lt; tab; i++) {
        System.out.print("    ");
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Maximum Sum Such That No Two Elements Are Adjacent]]></title>
    <link href="http://okc1.github.io/blog/2014/12/22/Maximum-sum-no-adjacent/"/>
    <updated>2014-12-22T00:00:00-08:00</updated>
    <id>http://okc1.github.io/blog/2014/12/22/Maximum-sum-no-adjacent</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/maximum-sum-such-that-no-two-elements-are-adjacent/">link</a></p>

<blockquote><p>Given an array of positive numbers, find the maximum sum of a subsequence that no 2 numbers should be adjacent.</p>

<p>Eg. (3, 2, 7, 10) should return 13 (3+10)</p>

<p>Eg. (3, 2, 5, 10, 7) should return 15 (3+5+7).</p></blockquote>

<h3>Solution</h3>

<p>It is an modified version of &ldquo;max sum subsequence&rdquo;. Answer given on <a href="http://www.geeksforgeeks.org/maximum-sum-such-that-no-two-elements-are-adjacent/">gfg</a> is:</p>

<blockquote><p>Loop for all elements in arr[] and maintain two sums &lsquo;incl&rsquo; and &lsquo;excl&rsquo; where:</p>

<p>incl = Max sum including the previous element</p>

<p>excl = Max sum excluding the previous element</p></blockquote>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public int solve(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    } else if (A.length == 1) {
        return A[0];
    } else if (A.length == 2) {
        return Math.max(A[0], A[1]);
    }

    // prePreMax is the max non-adjacency sequence ending 2 position ahead
    // preMax is the max non-adjacency sequence ending 1 position ahead
    int prePreMax = A[0];
    int preMax = A[1];
    int ans = 0;

    for (int i = 2; i &lt; A.length; i++) {
        ans = Math.max(ans, prePreMax + A[i]);
        // set the 2 variables: prePreMax, preMax
        int temp = preMax;
        preMax = Math.max(0, prePreMax + A[i]);
        prePreMax = Math.max(prePreMax, temp);
    }
    return ans;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Binary Search Tree 3Sum]]></title>
    <link href="http://okc1.github.io/blog/2014/12/18/Binary-Search-Tree-3Sum/"/>
    <updated>2014-12-18T00:00:00-08:00</updated>
    <id>http://okc1.github.io/blog/2014/12/18/Binary-Search-Tree-3Sum</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p>DLL - <a href="http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/">link</a></p>

<p>Inorder - <a href="http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/">link</a></p>

<blockquote><p>Given a BST, write a function that returns true if there is a triplet that sums to 0, returns false otherwise.</p></blockquote>

<h3>Solution</h3>

<p>We will solve the question just like we do <strong>[LeetCode 15] 3Sum</strong>. What is missing is an random access of tree nodes.</p>

<p>In fact, we do not need random access. Tree traversal (one after another in sequence) would be good enough.</p>

<p>Now there&rsquo;re 2 solution. <strong>First is to convert the tree to Double-linked list</strong>, then do 3Sum. The conversion takes O(n) time and O(logn) extra space, and 3Sum take O(n<sup>2</sup>). however doing this modifies the original tree.</p>

<p><strong>Second solution is to to inorder traversal and reversed inorder traversal</strong>. For me, this solution is preferred. Time and space used is same.</p>

<h3>Code</h3>

<p><strong>DLL way, written by me</strong></p>

<pre><code>public void findTriplet(TreeNode root, int target) {
    TreeNode[] dll = convertToDll(root);
    TreeNode head = dll[0];
    TreeNode tail = dll[1];
    // note that the bst inorder dll should already in sorted by value
    TreeNode first = head;
    while (first.right != null) {
        TreeNode left = first.right;
        TreeNode right = tail;
        while (left.val &lt; right.val) {
            int diff = first.val + left.val + right.val - target;
            if (diff == 0) {
                System.out.println("Found triplet: " + first.val + " "
                        + left.val + " " + right.val + " for sum of "
                        + target);
            }
            if (diff &lt;= 0) {
                left = left.right;
            }
            if (diff &gt;= 0) {
                right = right.left;
            }
        }
        first = first.right;
    }
}

private TreeNode[] convertToDll(TreeNode node) {
    TreeNode[] ans = new TreeNode[2];
    // do the left side of node
    if (node.left == null) {
        ans[0] = node;
    } else {
        TreeNode[] preAns = convertToDll(node.left);
        ans[0] = preAns[0];
        node.left = preAns[1];
        preAns[1].right = node;
    }
    // do the right side of node
    if (node.right == null) {
        ans[1] = node;
    } else {
        TreeNode[] postAns = convertToDll(node.right);
        ans[1] = postAns[1];
        node.right = postAns[0];
        postAns[0].left = node;
    }
    return ans;
}
</code></pre>

<p><strong>inorder way</strong> - basically is just <strong>iterator of binary tree</strong>.</p>
]]></content>
  </entry>
  
</feed>
