<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Z-string-search | Woodstock Blog]]></title>
  <link href="http://www.shuati123.com/blog/categories/z-string-search/atom.xml" rel="self"/>
  <link href="http://www.shuati123.com/"/>
  <updated>2017-05-22T02:03:16-07:00</updated>
  <id>http://www.shuati123.com/</id>
  <author>
    <name><![CDATA[Kevin Durant]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Trie Wildcard String Matching]]></title>
    <link href="http://www.shuati123.com/blog/2017/05/22/Trie-Wildcard-String-Matching/"/>
    <updated>2017-05-22T00:00:00-07:00</updated>
    <id>http://www.shuati123.com/blog/2017/05/22/Trie-Wildcard-String-Matching</id>
    <content type="html"><![CDATA[# Question

[link](https://discuss.leetcode.com/topic/54332/wildcard-on-trie/2)

> Given a trie data struture, implement add() and search() method, which support wildcard matching.

eg. If trie contains ["cool", "kid", "kindle", "kind"]

These would match: "co*l", "kind", "***"

These won't: "**", "kid*", "coo"

# Solution

First, know how to build a trie, then know how to search in Trie. This could be tricky. Do Read On!

1. Trie (root) start with an empty node. 
2. When do searching, __ALWAYS assumes that current TrieNode is matched__. I.e. do not check value of current TrieNode. Instead, check current TrieNode's children, and find a match.
3. The only case __you return true__, is when matching reaches current TrieNode, and __current TrieNode is an terminating node for a word__. 
4. Be careful and __do not confuse yourself__ for which node you gonna match, and when you return true. 

Read the code below. If you still have a hard time, read #2 and #3 above, again. 


# Code

	public boolean solve(TrieRoot trie, String word) {
		if (word == null || word.length() == 0) {
			return false;
		}
		return matchFromChildren(trie.getRoot(), word, 0);
	}
	
	private boolean matchFromChildren(TrieNode node, String word, int index) {
		// [important note] 
		// regardless of the value of node.letter, match word[index...] from node.children
		
		if (index > word.length()) {
			// impossible to reach here
			return false;
		} else if (index == word.length()) {
			// word is now fully matched, check if isTerminalNode(node)
			return node.isEndOfWord();
		}
		
		char curLetter = word.charAt(index);
		if (curLetter == '*') {
			for (TrieNode child: node.getAllChildren()) {
				if (matchFromChildren(child, word, index + 1)) {
					return true;
				}
			}
			return false;
		} else {
			TrieNode nextNode = node.getChild(curLetter);
			if (nextNode == null) {
				return false;
			} else {
				return matchFromChildren(nextNode, word, index + 1);
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Implement Trie and Suffix Tree]]></title>
    <link href="http://www.shuati123.com/blog/2015/01/28/implement-trie-suffix-tree/"/>
    <updated>2015-01-28T00:00:00-08:00</updated>
    <id>http://www.shuati123.com/blog/2015/01/28/implement-trie-suffix-tree</id>
    <content type="html"><![CDATA[### Trie Node

    public class TrieNode {
        boolean isLeaf;
        TrieNode[] child;

        public TrieNode(boolean isLeaf) {
            this.isLeaf = isLeaf;
            this.child = new TrieNode[26];
        }

        public void insert(String str) {
            if (str == null || str.length() == 0) {
                this.isLeaf = true;
                return;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                child[cur - 'a'] = new TrieNode(str.length() == 1);
            }
            child[cur - 'a'].insert(str.substring(1));
        }

        public boolean trieSearch(String str) {
            // have to consider leaf node
            if (str == null || str.length() == 0) {
                return isLeaf;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                return false;
            }
            return child[cur - 'a'].trieSearch(str.substring(1));
        }

        public boolean suffixTreeSearch(String str) {
            // suffixTreeSearch don't consider leaf node
            // cuz we search for prefix of suffixes
            if (str == null || str.length() == 0) {
                return true;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                return false;
            }
            return child[cur - 'a'].suffixTreeSearch(str.substring(1));
        }
    }

### Trie

    public class Trie {
        TrieNode root;

        public Trie(String[] input) {
            root = new TrieNode(false);

            for (String str : input) {
                root.insert(str);
            }
        }

        public boolean search(String query) {
            return root.trieSearch(query);
        }
    }

#### Suffix Tree

Suffix tree might also consider the __List of indexes__ thing, which I do not take into consideration in my code. 

    public class SuffixTree {
        TrieNode root;

        public SuffixTree(String input) {
            root = new TrieNode(false);

            for (int i = 0; i < input.length(); i++) {
                root.insert(input.substring(i));
            }
        }

        public boolean search(String query) {
            return root.suffixTreeSearch(query);
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Suffix Tree]]></title>
    <link href="http://www.shuati123.com/blog/2015/01/27/suffix-tree/"/>
    <updated>2015-01-27T00:00:00-08:00</updated>
    <id>http://www.shuati123.com/blog/2015/01/27/suffix-tree</id>
    <content type="html"><![CDATA[[ref](http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/)

### Suffix tree

Both KMP Algorithm and Rabin Karp Algorithm __pre-process the pattern__ to make the pattern searching faster. The best time complexity that we could get by preprocessing pattern is __O(n), where n is length of the text__. 

Now we will discuss an approach that __pre-processes the text__. A suffix tree is built of the text. After preprocessing text (building suffix tree of text), we can __search any pattern in O(m) time__ where m is length of the pattern.

Though search is very fast - just proportional to length of the pattern, it may become costly if __the text changes frequently__. It is good for fixed text or less frequently changing text though.

#### Suffix Tree VS. Trie

__A Suffix Tree is a compressed trie of all suffixes of the given text__. 

#### Compressed Trie

__A Compressed Trie__ is obtained from standard trie by joining chains of single nodes. 

Example, a standard trie: 

<img class="middle" src="/assets/images/standardtrieNew.png">

A Compressed Trie: 

<img class="middle" src="/assets/images/CompressedTrieNew.png">

#### build a Suffix Tree

1. Generate all suffixes of given text.
1. Consider all suffixes as individual words and build a compressed trie.

Eg.

    banana\0
    anana\0
    nana\0
    ana\0
    na\0
    a\0
    \0

Example question: __[CC150v4] 20.8 Full Text Search (Suffix Tree)__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Suffix Array]]></title>
    <link href="http://www.shuati123.com/blog/2015/01/27/suffix-array/"/>
    <updated>2015-01-27T00:00:00-08:00</updated>
    <id>http://www.shuati123.com/blog/2015/01/27/suffix-array</id>
    <content type="html"><![CDATA[[ref](http://www.geeksforgeeks.org/suffix-array-set-1-introduction/)

### Suffix Array

A suffix array is a sorted array of all suffixes of a given string. 

__Any suffix tree based algorithm__ can be replaced with an algorithm __that uses a suffix array__ enhanced with additional information and solves the same problem in the same time complexity. 

__Naive algorithm__ for construction of suffix array is to consider all suffixes, sort them using a O(nLogn) sorting algorithm and while sorting, maintain original indexes. Time complexity is _O(n^2 * Logn)__. 

There is an advanced __nLogn Algorithm__ algorithm available to read [here](http://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/). Basic idea is to "Sort according to first two characters" and then "according to first four character". 

Example question: __[Facebook] Query Search (HashMap, suffix array)__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Prefix Tree]]></title>
    <link href="http://www.shuati123.com/blog/2015/01/27/prefix-tree/"/>
    <updated>2015-01-27T00:00:00-08:00</updated>
    <id>http://www.shuati123.com/blog/2015/01/27/prefix-tree</id>
    <content type="html"><![CDATA[[ref](http://www.geeksforgeeks.org/trie-insert-and-search/)

### Prefix tree

1. Building a well balanced BST needs time proportional to M * log N, where M is maximum string length and N is number of keys in tree. 
1. Using trie, search in O(M) time. 
1. The penalty is on trie storage requirements.

### Implementation

1. Every node of trie consists of multiple branches. 
1. Each branch represents a possible character of keys. 
1. Mark the last node of every key as leaf node. 

	struct trie_node
	{
		int value; /* Used to mark leaf nodes */
		trie_node_t *children[ALPHABET_SIZE];
	};

Note that a __non-terminating node can also be marked as leaf__. Eg. 

                       root
                    /   \    \
                    t  'a'    b
                    |   |     |
                    h   n    'y'
                    |   |  \    \
                   'e'  s  'y'  'e'
                 /  |   |
                i   r   w
               /    |   |
             'r'   'e'  e
                        |
                       'r'

The leaf nodes are quoted in ''.

Insert and search costs __O(key_length)__, however the memory requirements of trie is __O(ALPHABET_SIZE * key_length * N)__ where N is number of keys in trie. 

__Compressed trie__, ternary search tree, etc. can be used to minimize memory requirements of trie. 
]]></content>
  </entry>
  
</feed>
